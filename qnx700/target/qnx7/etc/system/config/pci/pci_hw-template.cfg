################################################################################
#
# This file contains hardware specific information including PCI interrupt pin
# assignments (on a per Bus/Device/Function basis), IRQ mappings and chassis and
# slot assignments. It is optional and is enabled for use by setting the
# PCI_HW_CONFIG_FILE environment variable to the fully qualified pathname of
# the board specific file to use
#
# Note that the interrupt pin and IRQ assignments in this file are overrides and
# only necessary if a device must use pin based interrupts (instead of message
# based (MSI) interrupts) and an incorrect assignment has been made either
# because the PCI server could not determine which pin to use or because of
# hardware errata
#
# General Configuration File Requirements
# ---------------------------------------
#
# The file is divided into sections using the section tag [ ]. The appropriate
# parameters and associated values must be in the correct section in order to be
# utilized
#
# Unless specified differently in the section specific descriptions below, the
# following general rules apply
#
# 1. There should be only 1 entry per line
#
# 2. If a field is designated as optional or don't care, the field should
#    contain a dash (-)
#
# 3. A '#' character indicates that everything that follows to the end-of-line
#    is a comment and will be ignored
#
# This file is currently processed when the PCI server is started therefore any
# modifications require the PCI server to be restarted. This may change in the
# future
#
# Note that each HW dependent module may have specific interpretations for
# certain fields. If that is the case, the interpretation will be documented in
# the file for the section affected
#
# Below are a list of sections followed by the general requirements and
# interpretation of each of those sections
#
#		1. PCI Interrupt Pin Assignments and IRQ Mappings
#		2. Chassis and Slot Assignments
#		3. Address Space
#		4. Resizable BAR Overrides
#
#
# 1. PCI Interrupt Pin Assignments and IRQ Mappings
# -------------------------------------------------
#
# The format of this section of the file is as follows. All 3 fields are
# required
#
# Bx:Dy:Fz  Pin  IRQ
#
# or for ARI devices (which implies a device of 0)
#
# Bx:Fz     Pin  IRQ
#
# x, y and z specify the Bus, Device and Function respectively
# Pin identifies the PCI defined interrupt pin A, B, C or D. It may also be
#     wildcarded with '-' in which case the field will be ignored when searching
#     for a match
# IRQ specifies which IRQ the device interrupts on
#
# This allows a specific BDF to IRQ mapping to be made which takes into account
# a priori, what interrupt pin a device asserts and to which IRQ that interrupt
# pin is mapped for a specific board.
#
# CAUTION:
#
# When specifiying the BDF for devices in slots, be aware that the bus numbers
# assigned to devices in those slots will change depending on the type of device
# placed into a slot and whether or not all slots are occupied.
# For example, if a device which contains 1 or more bridges (or PCIe switches)
# is plugged into a slot which previously contained no device or contained a
# simple endpoint device, the bus number assignment to devices in subsequent
# slots will change. This is because subordinate bus numbers must now be
# assigned to the buses on the add in card and this will in turn change the
# starting bus number assigned to devices in subsequent slots and hence change
# what IRQ's are assigned to which devices.
# Also note that changing the SLOT_BUSNUM_RESERVE parameter in a server
# configuration file may have the same impact.
#
# The match criteria consists of the B:D:F and 'Pin' value therefore a unique
# entry consists of a single B:D:F and 'Pin' value.
# You may have multiple entries for the same B:D:F if 'Pin' is different. For
# example, you could have up to 4 entries per B:D:F to specify the mapping for
# each of the 4 PCI interrupt pins A, B, C and D.
#
# It should be noted that the Bx:Fz format for specifying a ARI device exists
# in order to allow the parser to distinguish between the 2 formats. Both
# result in a BDF being generated for use in matching when determining whether
# an external override applies (see pci/pci.h)
#
# It is possible, at the discretion of the HW module, to make either the 'Pin'
# field or the 'IRQ' field of an entry optional.
#
# For example, when searching for a match, the HW dependent module may use both
# the 'BDF' and the 'Pin' to match and hence find a unique IRQ or it may ignore
# the 'Pin' field effectively matching any PCI interrupt pin.
#
# Similarly, the IRQ field may be ignored if the HW dependent module is able to
# determine the IRQ based on the 'Pin' field. The configuration file for a
# specific board should specify any interpretations it makes regarding the
# entries in this section of the file.
#
#
# 2. Chassis and Slot Assignments
# -------------------------------
#
# For most boards, the chassis will be 0 and can effectively be ignored. The
# parameter exists because some PCI/PCIe based systems are configured with
# multiple chassis and the PCI server is designed to handle this.
#
# With the exception of these chassis based designs, it is board specific how
# slots are numbered and to which bridge device each are connected.
# Additionally, there may be non PCI based slots that are included in the
# overall system numbering scheme hence we provide the ability to specify which
# slot numbers are attached to which bridge devices.
#
# The syntax of a chassis and slot record consists of multiple fields each
# separated by a semi-colon (;) as follows
#
# <vid>;<did>;<idx>;<slot #>;<device #>
#
# The first 2 fields are the PCI SIG assigned Vendor and Device ID's and these
# are fixed for a given device. Typically, even if there are multiple of the
# same class of device, the assigned device ID will be different and the Vendor
# and Device ID combination will uniquely identify a physical device. Both of
# these fields should be specified in hexadecimal without the leading 0x.
#
# The third field is a device index or instance. For systems which may contain
# more than 1 of the same device (in which the exact same Vendor and Device
# ID's would exist) the <idx> field allows a specific physical device to be
# selected. The <idx> value can be determined with the 'pci-tool' and the
# numbering starts with 0.
#
# The fourth field is for the chassis and slot # which is specified with the
# Cx:Sy syntax (Note the colon ':' separator for this sub-field)
#
# 	ex. C0:S2 corresponds to chassis 0, slot 2. Slot numbers start at 1
#
# The Cx:S is optional allowing for just the slot number to be specified for
# systems which do not have additional chassis'
#
# The fifth field specifies the device number assigned to the slot. This field
# does not apply to PCIe as all devices on the downstream end of a link have an
# implied device number of 0 and therefore this field can be omitted when the
# chassis and slot record is used to override a PCIe assigned slot number.
# For PCI, which is a bus based interface, multiple slots may be connected to
# the secondary bus of the bridge identified by the Vendor and Device ID. Each
# of these slots will be associated with a device number which is fixed by the
# board design. In this case, multiple chassis/slot records may be entered with
# the same <vid>, <did> and <idx> and different <slot #> and <device #> fields.
#
# The format of the field is Dx, where 'x' specifies the device number in
# decimal
#
# IMPORTANT
#
# If the device field is missing, the device number will be assumed to be 0.
# For a PCI bus, this will only be valid if there are no embedded PCI devices on
# the same secondary bus so ensure that this is the case. In general it is
# always better to explicitly specify the device number for a PCI bridge
#
# The following example is for a PCIe link. Both entries produce the same result
#
# 1111;2222;0;C0:S3;D0
# 1111;2222;0;3
#
# The following example is for 3 PCI slots 4, 5 and 6
#
# 1111;2222;0;C0:S4;D5
# 1111;2222;0;C0:S5;D6
# 1111;2222;0;C0:S6;D7
#
#
# 3. Address Space
# ----------------
#
# This section allows for board dependent manipulation of the address spaces
# used during server configuration. It currently supports the following
# parameters
#
# ASPACE_FILTER=
#
#
# The ASPACE_FILTER parameter can be used to restrict the address space
# available for assignment during the PCI server configuration phase.
# 
# When the PCI server is started, the loading of the HW dependent module will
# populate the resource database with the address space available for assignment
# during configuration. This information can be obtained with the 'rsrcdb_query'
# utility.
# On some platforms it may be desirable to restrict which address spaces are
# utilized and the ASPACE_FILTER parameter provides this capability.
#
# The format of the ASPACE_FILTER parameter is as follows. All 3 fields are
# required
#
# ASPACE_FILTER=<type>:<start>:<end>
#
# The filter consists of the region between <start> and <end> inclusive
#
# Each field of the filter value is separated by a colon (:)
# <type> must be MEM or IO (case invariant)
# <start> must be less than <end>
# <start> and <end> may be specified in any base
#
# The filter region should meet the minimum alignment requirements of <type>.
# The minimum alignment requirements for MEM and IO are defined in pci/pci.h as
# pci_asAttr_e_ALIGN_MEM_MIN (16 bytes) and pci_asAttr_e_ALIGN_IO_MIN (4 bytes)
# respectively.
# For type MEM, <start> & 0xF == 0 and (<end> + 1) & 0xF == 0
# For type IO, <start> & 0x3 == 0 and (<end> + 1) & 0x3 == 0
#
# A error will be logged and the filter ignored if these conditions are not met
#
# If multiple entries exist, the filters are processed in the order listed in
# this file. As address space regions are added to the resource data base by the
# HW dependent module, the filters are checked in order and the first filter
# that matches a region will be used to process the region. Once a match occurs,
# filter processing on the region terminates
#
# For example
#
# ASPACE_FILTER=MEM:0xa0000000:0xa7ffffff
#
# would filter out 128 MB (0x8000000) from 0xa0000000 to 0xa7fffff 
#
#
# 4. Resizable BAR Overrides
# --------------------------
#
# This section provides user control over the Resizable BAR settings for a given
# device. By default, this section is empty and the handling of Resizable BAR's
# for a device will be as described in the 'use' information for the RBAR
# capability module pcie_xcap-0x0015.so, section "Default Behaviour".
#
# This section describes the syntax required in order to override the default
# behaviour as referred to in the 'use' information for the RBAR capability
# module pcie_xcap-0x0015.so, section "User Controlled Behaviour".
#
# Note that if the aforementioned RBAR capability module is blacklisted or
# otherwise cannot be found, the settings in this section will be ignored.
#
# The [rbar] section consists of 1 or more records each of which apply to a
# specific device uniquely identified by its VID, DID and instance. If more
# than 1 record is detected for the same VID/DID/instance, the first valid
# record will be used.
# Note that a valid record means that the record is correctly formatted and not
# that the specified size is supported. The check for supported sizes is done
# when the record is retrieved and so if an otherwise valid record with an
# invalid size is specified, succeeding valid records with the same vid/did/idx
# will be ignored.
#
# Invalid or incorrectly formatted records will be ignored and a warning will
# be logged (if the optional logging module is enabled).  
#
# The syntax of a resizable BAR record consists of multiple fields each
# separated by a semi-colon (;) as follows
#
# <vid>;<did>;<idx>;<bar setting>;<bar setting>;...
#
# The first 2 fields are the PCI SIG assigned Vendor and Device ID's and these
# are fixed for a given device. Typically, even if there are multiple of the
# same class of device, the assigned device ID will be different and the Vendor
# and Device ID combination will uniquely identify a physical device. Both of
# these fields should be specified in hexadecimal without the leading 0x.
#
# The third field is a device index or instance. For systems which may contain
# more than 1 of the same device (in which the exact same Vendor and Device
# ID's would exist) the <idx> field allows a specific physical device to be
# selected. The <idx> value can be determined with the 'pci-tool' utility
# using the -V (vid) and -D (did) search criteria. Numbering starts with 0.
#
# The 4th thru 9th fields select the BAR size setting for each Resizable BAR the
# specified device implements. There can be at most 6 <bar setting> fields
# corresponding to each of the six possible PCI defined BAR's.
#
# The <bar setting> fields consist of 2 sub-fields with the following syntax
#
#    <bar#:size>
#
# (Note the colon ':' separator for the sub-field separation)
#
# The 'bar#' sub-field must be a value between 0 and 5 corresponding to one of
# the six possible PCI defined BAR's.
#
# The 'size' sub-field is used to select which of 32 possible size values
# (numbered 0 to 31) to use for the resizable BAR and it corresponds directly to
# the definition of the 'capability register' of the Resizable BAR capability as
# defined by the PCIe specification. It does not correspond to the 'BAR size'
# field of the control register.
#
# In general, the <size> sub-field is defined as BAR_size = (65536 << size) with
# the minimum BAR size currently defined to be 1 MB and the maximum BAR size
# currently defined to 512 GB.
# This results in valid <size> sub-field values between 4 and 23 inclusive as
# per the aforementioned definition in the PCIe Specification.
#
#     ex. 1:8 corresponds to a selection of 16 MB for BAR 1
#
# It is the users responsibility to ensure that the <bar setting> fields
# correspond to both an implemented BAR and to supported sizes. If either of
# these conditions is not met, the record will be ignored.
#
# Also note that if 64 bit BAR's are implemented, then the even numbered BAR's
# (ie. 0, 2, 4) are the ones to use in the <bar setting> field.
#
# Example entry
# -------------
# For the second device with VID/DID 0x1234/0xabcd, use 16MB for BAR 1, 256MB
# for BAR 3 and 1 MB for BAR 5 (none of these could be 64 bit BAR's)
#
# 1234;abcd;1;1:8;3:12;5:4
#
#
#############################  S E C T I O N  ##################################
#
[interrupts]
#
# PCI Interrupt Pin Assignments and IRQ mappings
# ----------------------------------------------
#


#############################  S E C T I O N  ##################################
#
[slots]
#
# Chassis and Slot Mappings
# -------------------------
#


#############################  S E C T I O N  ##################################
#
[aspace]
#
# Address Space
# -------------
#
# ASPACE_FILTER=
#


#############################  S E C T I O N  ##################################
#
[rbar]
#
# Resizable BAR Overrides
# -----------------------
#
