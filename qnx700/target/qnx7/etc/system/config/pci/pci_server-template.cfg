################################################################################
#
# PCI Server runtime configuration file
#
# This file (or one similar) can be used to control the runtime behaviour of the
# PCI server. It is utilized by specifying it as the parameter to the --config=
# command line option.
#
# Parameters and their acceptable values are described below. Parameter values
# are (typically) case invariant however certain values like names are not
#
# The file is separated into sections. Each section describes the parameters
# which can be set and what effect they will have. Each section is started with
# a [<section type>] declaration. All parameters after the [<section type>]
# declaration and upto the next [<section type>] declaration (or end-of-file),
# will be treated as belonging to the section. The [] character sequence should
# not be used in any non-commented section elsewhere in the file 
#
# For the purpose of documentation, all parameters are included in this file
# along with their default values. These are left commented out with '##'.
# Changes should be made by copying the line and changing the value. That way
# the default value is always known.
#
# All text following a '#' until the end-of-line will be treated as a comment
#
# The '\' is a line continuation character and can be used to delimit parameter
# values for parameters that accept more than one value. If mutliple parameter
# values are placed on a single line, a parameter specific delimiter is used
# (see the specific parameter for details)
#
# White space is ignored unless otherwise stated
#
# NOTE:
# Processing of this file occurs in reverse order (ie. the last section is
# processed first, followed by the second last, etc finishing with the first
# named section). If the [envars] section is included, it is suggested that it
# be placed as the last section so that the environment variables are applied
# to remaining sections as applicable
#
# The following sections are currently defined
#
# [envars]
# [runtime]
# [buscfg]

#-------------------------------------------------------------------------------
[envars]

# This section allows all required and optional environment variables (except
# PCI_SLOG_MODULE) to be specified as described in pci/pci.h.
#
# If logging is required in the PCI server, then the PCI_SLOG_MODULE environment
# variable must be set in the environment in which the PCI server is run (either
# via export or on the command line) as PCI_SLOG_MODULE=pci_slog.so (assuming
# it resides in /lib/dll/pci/)
#
# The reason for this is because logging starts before this configuration file
# is processed and if the first attempted log finds the PCI_SLOG_MODULE
# environment variable unset, logging is disabled. This is by design.

# Control of logging verbosity can be done either by setting of the
# PCI_BASE_VERBOSITY environment variable prior to starting the PCI server so
# that it applies to the PCI_SLOG_MODULE when it is initially loaded, with
# the -v command line option, or in the [envvar] section of this file. If
# specified in this file, then the current environment setting, if specified,
# will be overridden.
#
# Environment variables will be added to the current environment of the PCI
# server and will override any existing variables. Refer to pci/pci.h for
# details about each of the environment variables.
#
# Note that only environment variables applicable to the PCI server are listed
# in this section
#
# Note that the PCI_SERVER_BUSCFG_MODULE environment variable is actually
# contained in the [buscfg] section 

# Mandatory environment variables

PCI_HW_MODULE = your_file_here

#    <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
# Optional environment variables (no defaults). If not specified, the module(s)
# will not be loaded unless the environment variable is already set in the
# environment of the PCI server when its started

# PCI_CAP_MODULE_DIR = /lib/dll/pci
# PCI_DEBUG_MODULE = /lib/dll/pci/pci_debug.so
# PCI_HW_CONFIG_FILE = board specific HW module configuration file

# The PCI_BASE_VERBOSITY environment variable allows slog and debug output to
# be controlled for pre-existing binaries. See pci/pci.h for details
## PCI_BASE_VERBOSITY = 0

# The PCI_MODULE_BLACKLIST provides the means by which specific modules can be
# prevented from being loaded

# PCI_MODULE_BLACKLIST =

#-------------------------------------------------------------------------------
[runtime]

# This section contains various server runtime settings

## MULTITHREADED = yes
# The following SERVER_THREADS_* parameters are only relevant if MULTITHREADED
# is 'yes' (which it is by default)
## SERVER_THREADS_LO_WATER = 2
## SERVER_THREADS_HI_WATER = 4
## SERVER_THREADS_MAX = 50
## SERVER_THREADS_INCREMENT = 1

# Note that the MULTITHREADED parameter applies only to server main message
# processing. It does not, for example, apply to the server event handling
# module which creates additional event handling threads for the purpose of
# managing events related to device interrupts. Those threads are not governed
# by the above parameters. Other server modules may add additional processing
# threads also not governed by the above parameters. Refer to the documentation
# for the specific server module

#    <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
# The default namespace node name for the PCI server is "/dev/pci" however this
# can be changed with the SERVER_NODE_NAME parameter. This could be used to run
# multiple instances of the PCI server however this non-standard (and
# non-sanctioned) usage should be done with caution.
#
# Note that if the server namespace node name is changed, the
# PCI_SERVER_NODE_NAME environment variable will have to be similarly changed in
# order for driver software to attach to any PCI devices. See pci/pci.h for a
# description of the PCI_SERVER_NODE_NAME environment variable.
#
# It is important to note that the '-n' command line option to the PCI server
# can also be used to set the PCI server node name. If that option is provided
# together with the SERVER_NODE_NAME option, the effective node name will be
# the one associated with the '-n' command line option. If this is different
# than the SERVER_NODE_NAME parameter a warning will be logged for the
# inconsistency

## SERVER_NODE_NAME = /dev/pci

#    <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
# The PCI_SERVER_MODULE_LIST provides the means by which additional PCI server
# functionality can be enabled. If multiple modules will be loaded, they can be
# specified as follows
#
#	- on a single line delimited with a colon (:)
#		ex. PCI_SERVER_MODULE_LIST = pci_server-foo1.so:pci_server-foo2.so
#	- on multiple lines delimited with the line continuation character '\'
#		ex. PCI_SERVER_MODULE_LIST = pci_server-foo1.so \
#									 pci_server-foo2.so
#
# All server modules MUST begin with the "pci_server" prefix and should contain
# the ".so" suffix. The remaining portion of the name is made up of
# alphanumerics plus '_', '-', '/' and '.' characters only
# 
# Modules can be specified as a relative pathname or with a leading '/'. If a 
# realtive pathname is used, the module must exist in the path starting with the
# "/lib/dll/pci/" prefix. For example, a relative pathname of
# "somedir/pci_server-foo.so" would need to exist in the absolute path
# "/lib/dll/pci/somedir/pci_server-foo.so".
# If the first character of the name is '/', the name must specify the full path
# to the module
#
# The modules will be loaded in the order specified in the list and after the
# server enumeration (and optional bus configuration) has successfully
# completed. If a module is specified more than once, the additional entries
# will be ignored
#
# optionality is provided to the modules by including a comma (,) separated list
# of arguments. These arguments are parsed out and passed as 'argv's' to the
# module initialization routine which can then use standard getopt() and
# getlong_opt() calls to process them
#
#	ex.   PCI_SERVER_MODULE_LIST = pci_server-foo1.so,-x3,--start=fresh \
#								   pci_server-foo2.so,--enabled,t3
#
# It is **important** that there is no whitespace in the options list including
# between the module name and the first comma (,). Additionally, the options
# themselves **cannot** use a comma (,) to delimit.
#
# Examples of illegal module command line parameter lines are as follows
#
#	1. pci_server-foo1.so ,-x3,--start=me
#	2. pci_server-foo1.so, -x3,--start=me
#	3. pci_server-foo1.so,-x3, --start=me
#	4. pci_server-foo1.so,-x 3,--start=me
#	5. pci_server-foo1.so,-x3,--start= me
#
# There are other combinations but hopefully you get the idea.
#
# Additionally, there is no support for multi-valued module options. If you want
# to use a multi-valued module option, for example
# 
#	6. pci_server-foo1.so,-x3,--start=me,up
#
# it should be specified as
#
#	6. pci_server-foo1.so,-x3,--start=me,--start=up
# 
# Refer to the specific module for details on what functionality they provide

# PCI_SERVER_MODULE_LIST =

#    <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
# The BUS_SCAN_LIMIT parameter specifies the highest bus to be scanned during
# the PCI bus enumeration phase. It can be used to deal with certain types of
# device errata or to shorten the enumeration phase if you know the maximum
# number of buses that can exist in your system
#
# Note that although this parameter does not affect the highest assigned bus
# number, it will impact the enumeration. This must be kept in mind if bus
# reservations are made with the SLOT_BUSNUM_RESERVE parameter (see below) 
#
## BUS_SCAN_LIMIT = 255

#-------------------------------------------------------------------------------
[buscfg]

# This section contains bus configuration settings and parameters.
# This includes, but is not limited to, the setting of bridge secondary and
# subordinate bus numbers and address space assignments of all bridges and
# devices. It also allows certain run time controls over the bus configuration
# process. Unless otherwise specified, these are only relevant if
# DO_BUS_CONFIG = yes|true otherwise they are ignored.
#
# It is important to note that the '-c' command line option to the PCI server
# will force configuration of the bus. If that option is provided together with
# the --config=<this file> option, bus configuration will take place regardless
# of the DO_BUS_CONFIG parameter value however the other bus configuration
# variables will be utilized. Effectively, the '-c' option has the effect of
# setting DO_BUS_CONFIG = yes|true. A warning will be logged in the case of an
# inconsistency
#
# To enable bus configuration via this file, a case invariant 'yes' or 'true' is
# required. The PCI_SERVER_BUSCFG_MODULE environment variable can be used to
# select which configuration module to use. If this environment variable is not
# set and configuration is enabled, the default configuration module is used
# (see below)

## DO_BUS_CONFIG = no

#        <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
## ASPACE_ENABLE = all|mem|io

# In recent UEFI based x86 platforms, it has been observed that even though
# memory and/or I/O address spaces are assigned to devices, that in some
# circumstances the address spaces are not enabled in the CMD register. The
# ASPACE_ENABLE parameter and --aspace-enable command line option have been
# added to correct for this and both operate identically with the command line
# option taking precedence. A warning will log any inconsistency
#
# The parameter can be specified with one of 3 case invariant values
#
#    all - all assigned address spaces will be enabled
#    mem - only assigned memory address spaces will be enabled
#     io - only assigned I/O address spaces will be enabled
#
# << IMPORTANT >>
#
#  1. This 'buscfg' parameter DOES NOT require DO_BUS_CONFIG to be set to 'yes'
#     or 'true' and in fact this parameter is only relevant in enumeration only
#     mode (ie. no '-c' command line option and/or DO_BUS_CONFIG=no) since when
#     run in configuration mode, the PCI server will automatically enable any
#     assigned address spaces
#  2. This parameter and the --aspace-enable command line option operate on all
#     devices. If it is not desirable to enable the assigned address spaces for
#     all devices, pci-tool --write='cfg:4,2|=3' run after the pci-server but
#     before the device driver in either the build file startup-script or other
#     start script can be used to selectively enable device address spaces
#
#        <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
# The DO_PCIe_LINK_RETRAINING parameter controls whether or not link retraining
# is performed for PCIe links during device enumeration. A value of 'yes' or
# 'true' will cause link training to be performed. A value of 'no' or 'false'
# will not perform PCIe link retraining. The default is to not perform
# additional link retraining
#
# NOTES
# -----
# This parameter does not affect any link retraining required as a result of a
# live insertion in hot plug capable systems. It only applies to the initial
# enumeration phase. Additionally, this parameter operates independent of the
# DO_BUS_CONFIG parameter setting
#
# If you intend to enable ASPM for PCIe links, its is suggested that
# DO_PCIe_LINK_RETRAINING = yes|true. In order to provide proper L0s and L1
# latency values, link retraining must be done after the common slot clock
# configuration has been determined. Setting DO_PCIe_LINK_RETRAINING = yes|true
# will accomplish this. If your pre-boot environment (ex. BIOS) does clock
# configuration and retraining this parameter can be left unset.  
#
# Enabling link retraining will affect the overall enumeration time. The PCI
# Express Specification states that a delay of 100 msec is required after link
# retraining completes. Since the enumeration phase is done in sequential order,
# this means that approximately 100 msec will be added for each PCIe port with
# a connected device or a device in an implemented slot

## DO_PCIe_LINK_RETRAINING = no

#        <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
# Although the PCI_SERVER_BUSCFG_MODULE is actually an environment variable, it
# is contained in this section
#
# Most, if not all of the parameters in the [buscfg] section will require a
# bus configuration module to be specified with the PCI_SERVER_BUSCFG_MODULE
# environment variable. That can be done within this file or directly in the
# environment of the PCI server process. If configuration is enabled and this
# parameter is not set, the default configuration file will be utilized.
#
# Note that PCI server bus configuration modules can be identified with the
# prefix 'pci_server-buscfg-'

## PCI_SERVER_BUSCFG_MODULE = /lib/dll/pci/pci_server-buscfg-generic.so

#        <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
# The SLOT_ASPACE_RESERVE parameter is provided to allow address space to be
# reserved for a physical slot. This could be used for live insertion/removal
# (ie. hotplug) support to ensure that enough address space is set aside by the
# upstream bridge for any PCI/PCIe card that the user may want to insert into
# the slot without having to reconfigure the entire hierarchy.
#
# For example, if a hotplug slot does not have any device inserted when it is
# enumerated, there will be no address space configured in the bridge for that
# slot. If a device is subsequently live inserted, the only way to configure it
# is to reconfigure the bridge hierarchy upstream of the bus segment on which
# the slot resides. This will have system wide impacts that may not be
# desireable. The SLOT_ASPACE_RESERVE parameter allows address space to be
# reserved for a slot such that a reconfiguration is not necessary.
#
# If only cards of the exact same type and address space requirements will ever
# be inserted into a particular slot and one of them is present when the bus is
# enumerated, then this parameter is not required. If however cards with
# differing address space requirements could be used in the same (hotplug) slot,
# then this parameter can be used to reserve enough address space of the
# particular type(s) to accommodate all cards that could be inserted.
#
# By way of a simple example, suppose a card that has only I/O address space
# requirements resides in the only bridge slot when the bus is enumerated. The
# bridge hierarchy upstream of that device will only be allocated I/O address
# space and subsequently configured to only allow I/O accesses to its secondary
# bus. If that card is then replaced with a card that utilizes memory and/or
# prefetchable memory address spaces, or that has a larger I/O space than the
# initial card, a reconfiguration of the hierarchy would be required in order to
# utilize that device. This reconfiguration may not be desireable in a running
# system hence the ability to reserve enough of the required address spaces for
# the different types of cards that may be live inserted into a slot is
# configurable
#
# Bridges with multiple slots
# ---------------------------
# Note that since PCIe is a point-to-point interconnect, it can support at most
# one slot per port and hence the multi-slot discussion which follows does not
# apply.
#
# A PCI bridge may support multiple slots. Each of those slots can have address
# space reserved using the SLOT_ASPACE_RESERVE parameter and in order to provide
# the most flexibility, there are 2 reservation attributes which can be
# specified which have different allocation behaviours.
#
# The first attribute is named RESERVED which indicates that the specified
# reservation represents a guaranteed amount of address space of the particular
# type for the slot.
#
# The second attribute is named SHARED which indicates that the specified
# address space reservation can be shared amongst multiple slots.
#
# By using multiple reservation records, a combination of attributes and
# reservation sizes can be established to satisfy the system requirements.
#
# The following examples illustrate the address space assignment behaviour for a
# multi-slot bridge for each of the attributes. In all the examples, a 2 slot,
# hotplug bridge is assumed with slots numbered 1 and 2.
#
# example 1
# ---------
# both slots have a shared 1 MB memory address space reservation and are
# initially empty
#
# When the bus is enumerated, 2MB of memory address space will be reserved in
# the bridge (1 MB for each slot) even though no devices are present
#
# scenario 1: a device requiring only 1MB of memory space is inserted into one
#             of the slots. The device will be configured and useable. A second
#             device (again requiring 1MB of memory address space) is
#             subsequently inserted into the other slot. Because 1MB of memory
#             address space is still available from the 2MB total shared
#             reservation, it will be configured and useable
#
# scenario 2: a device requiring 1.5MB of memory space is inserted into one
#             of the slots. Because there is a 2MB shared reservation for both
#             slots, the device will be configured and useable. A second device
#             requiring 1MB of memory address space is subsequently inserted
#             into the other slot. Because only 0.5MB of memory address space is
#             still available from the 2MB total shared reservation, it will not
#             be able to be configured without changes to the upstream bridge
#             hierarchy
#
# scenario 3: a device requiring no memory address space but 4KB of I/O address
#             space is inserted into one of the slots. Because there is no I/O
#             address space available, the device will not be configured or
#             or useable without changes to the upstream bridge hierarchy
#
# example 2
# ---------
# slot 1 has a reserved 1MB memory address space reservation, slot 2 has a
# shared 1MB memory address space reservation and both slots are initially empty
#
# scenario 1: a device requiring only 1MB of memory space is inserted into one
#             of the slots. The device will be configured and useable. A second
#             device (again requiring 1MB of memory space) is subsequently
#             inserted into the other slot. Because 1MB of memory address space
#             is still available from the 2MB total reservation, it will be
#             configured and useable
#
# scenario 2: a device requiring 1.5MB of memory space is inserted into slot 1.
#             Because slot 2 has a shared reservation and no card yet resides in
#             the slot, the additional 0.5MB required by the device in slot 1
#             will be obtained from the slot 2 reservation and the device will
#             be configured and useable. A second device requiring 1MB of memory
#             address space is subsequently inserted into slot 2. Because only
#             0.5MB of shared memory address space is still available, it will
#             not be able to be configured without changes to the upstream
#             bridge hierarchy. A device requiring 0.5MB or less of memory
#             address space inserted into slot 2 would be able to be configured
#             and useable
#
# scenario 3: a device requiring 1.5MB of memory space is inserted into slot 2.
#             Because slot 1 has a reserved reservation of 1MB, the additional
#             0.5MB required by the device in slot 2 will not be obtained from
#             the slot 1 reservation and the device will not be configured and
#             useable without changes to the upstream bridge hierarchy
#
# example 3
# ---------
# both slot 1 and slot 2 have a reserved 1MB memory address space reservation
# and the slots are intially empty
#
# In any scenario, only devices requiring 1MB or less of memory address space
# could be placed in either slot
#
# SLOT_ASPACE_RESERVE parameter usage
# ---------------------------------------
#
# The SLOT_ASPACE_RESERVE parameter may be specified multiple times.
# If duplicate entries are found for a slot, the last entry will be used. The
# use of multiple reservation records permits the size and attributes of each
# address space type to be independently specified. A size value of zero results
# in no reservation being processed for that address space type.
#
# For example
#
# SLOT_ASPACE_RESERVE=S;2;0x1000
# SLOT_ASPACE_RESERVE=R;2;0;0x10000
# SLOT_ASPACE_RESERVE=S;2;0;0;0x20000
#
# would create a reservation for slot 2 with shared I/O and prefetchable memory
# address spaces (of the specified sizes) and a reserved memory address space
# reservation (of the specified size). Of course the first and third records
# could have been combined as
#
# SLOT_ASPACE_RESERVE=S;2;0x1000;0;0x20000
#
# The syntax of the SLOT_ASPACE_RESERVE parameter consists of multiple fields
# each separated by a semi-colon (;) as follows
#
# SLOT_ASPACE_RESERVE=<attribute>;<slot>;<I/O>;<MEM>;<PFMEM>
#
# The first field is for the reservation attributes. A single character 'S' or
# 'R' is used to specify a SHARED or RESERVED reservation respectively (see
# multi-slot discussion above)
#
# The second field is for the chassis and slot #'s which are specified with the
# Cx:Sy syntax (Note the colon ':' separator for this sub-field)
#
# 	ex. C0:S2 corresponds to chassis 0, slot 2. Slot numbers start at 1
#
# The Cx:S is optional allowing for just the slot number to be specified for
# systems which do not have additional chassis'
#
# The address space reservations are made up of 3 identically formatted
# reservation fields
#
# The first reservation field is for I/O address space, the second for memory
# address space and the third is for prefetchable memory address space. If a
# reservation is not required for an address space type, the field should
# contain a single value of 0 (reservation fields with a size of 0 are ignored).
# A reservation field can also be blank if the remaining address spaces will not
# be used. See the examples below 
#
# The format of the address space size field is further broken down into size
# and alignment subfields separated by a comma (,) as follows
#
# <reservation size>,<reservation alignment>
#
# If not specified, or incorrectly specified, a minimum <reservation alignment>
# based on address space type will be enforced. The alignment value is used as
# a restriction when allocating address space for a device. If you do not know
# what value to put, leave it unset and the default alignment for the specified
# type will be used.
#
# Note that size values will be rounded up to the minimum alignment required for
# the address space type
#
# Valid reservations as well as reservation syntax errors will be logged
# assuming the PCI_SLOG_MODULE environment variable is set and slogger is
# running
#
# examples
# --------
#
# reserve a shared 4KB I/O address space and 1MB prefetchable memory address
# space for slot 2, default alignment
#
#    SLOT_ASPACE_RESERVE=S;2;0x1000;0;0x100000
#
# reserve an un-shared 8KB, 256 byte aligned I/O address space, 8MB, 2MB aligned
# memory space and 1 MB prefetchable memory address space in slot 5 of chassis 3
#
#    SLOT_ASPACE_RESERVE=R;C3:S5;0x2000,256;0x800000,0x200000;0x100000
#
# reserve a shared 1MB prefetchable memory address space and a reserved 2 MB
# memory address space for slot 1
#
#    SLOT_ASPACE_RESERVE=S;1;0;0;0x100000
#    SLOT_ASPACE_RESERVE=R;1;0;0x200000
#

#        <><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
#
# The SLOT_BUSNUM_RESERVE parameter is provided to allow a range of bus numbers
# to be reserved for a specified slot. This could be used for live
# insertion/removal (ie. hotplug) support to ensure that enough subordinate bus
# numbers are set aside by the upstream bridge for any PCI/PCIe card containing
# one or more bridges (PCI bridges or PCIe switches) that the user may want to
# insert into the slot without having to reconfigure bridges which have been
# assigned subsequent bus numbers. It is analogous to and used in conjunction
# with the SLOT_ASPACE_RESERVE parameter.
#
# This parameter is only necessary if it is anticipated that a card will be
# added which contains at least 1 bridge device. This parameter can be used to
# reserve bus numbers even if a card is added which does not contain a bridge.
#
# The syntax of the SLOT_BUSNUM_RESERVE parameter consists of multiple fields
# each separated by a semi-colon (;) as follows
#
# SLOT_BUSNUM_RESERVE=<slot>;<num>
#
# The first field is for the chassis and slot # which are specified with the
# Cx:Sy syntax (Note the colon ':' separator for this sub-field)
#
# 	ex. C0:S2 corresponds to chassis 0, slot 2. Slot numbers start at 1
#
# The Cx:S is optional allowing for just the slot number to be specified for
# systems which do not have additional chassis'
#
# The second field specifies the number of bus numbers to reserve for the slot
# not including the bus number the slot resides on. A bus number should be
# reserved for each bridge residing on an add-in card. A value of 0 is permitted
# and is considered a valid record.
#
# Only one SLOT_BUSNUM_RESERVE record should be specified for a slot. If
# duplicate entries for the same slot are found, a warning will be logged and
# the last valid record will be used.
#
# Notes
# -----
# This parameter is not required for any slot residing on the highest numbered
# bus since there would be no bridge with a higher bus number that would limit
# the assignment of the next available bus number to an add in card with a
# bridge
#
# This parameter is independent of and not limited by BUS_SCAN_LIMIT however
# if the number of buses reserved exceeds the BUS_SCAN_LIMIT value, subsequent
# bridges (either peers or subordinates) will not be fully enumerated 
#





