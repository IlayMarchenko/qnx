#!/bin/sh

dhclientverbose_echo()
{
if [ ! -z "$DHCLIENT_VERBOSE" ]; then
    echo "$1"
fi
}

dhclientverbose_echo "dhclient-script ==="
dhclientverbose_echo "dhclient-script QNX DHCP client script called reason: $reason"
dhclientverbose_echo "dhclient-script SOCK $SOCK RESOLV_TO_MEMORY $RESOLV_TO_MEMORY MODIFY_RESOLV $MODIFY_RESOLV"
dhclientverbose_echo "dhclient-script NO_DEF_ROUTE $NO_DEF_ROUTE"
dhclientverbose_echo "dhclient-script interface $interface medium $medium pid $pid SOCK $SOCK"
dhclientverbose_echo "dhclient-script addr ${new_ip6_address}/${new_ip6_prefixlen}"
dhclientverbose_echo "dhclient-script new_routers $new_routers"
dhclientverbose_echo "dhclient-script new_static_routes $new_static_routes"
dhclientverbose_echo "dhclient-script new_dhcp6_name_servers $new_dhcp6_name_servers"
dhclientverbose_echo "dhclient-script new_domain_search $new_domain_search"
dhclientverbose_echo "dhclient-script new_domain_name $new_domain_name"
dhclientverbose_echo "dhclient-script new_domain_name_servers $new_domain_name_servers"
dhclientverbose_echo "dhclient-script new_interface_mtu $new_interface_mtu"
dhclientverbose_echo "dhclient-script new_subnet_mask $new_subnet_mask"
dhclientverbose_echo "dhclient-script ==="


# XX REMOVE:
#State machine:
# connected -> start dhclient 
# "PREINIT" -> INIT -> reboot timeout ->
# if lease -> REBOOTING
# else -> INIT
# INIT -> send Discover -> SELECTING
# SELECTING got Offer -> send Request REQUESTING
# else SELECTING -> SELECTING
# REQUESTING got Ack -> BOUND "BOUND" "RENEW" "REBOOT" "REBIND"
# BOUND lease expire -> RENEWING
# got NAK -> INIT
# Panic -> FAIL! -> INIT
# -> RELEASE

WORKDIR=/var

# XX empty leases we start over because we may be connecting to new network each time...
# and we don't want a growing leases file!
# XX Get rid of reboot state??
# XX Could just do this by wpa_pps starting a script which empties leases before starting dhclient

# XX When we fail renew we should go to disconnected state and revert PPS changes


PPSOBJ=/pps/services/networking/control
#PPSOBJ=/var/test-dhclient

make_pps_conf() {
	dhclientverbose_echo "make_pps_conf"
  if [ "x$new_routers" != x ]; then
		# IPv4
		if [ -e $PPSOBJ ]; then
      # only one router supported
			for router in $new_routers; do
				GW=\"gateway\":\"$router\"
                # MAH: Added the 'break' for now, but a PR should be raised.
                break
			done
			
			NAMESERVERS=
			for nameserver in $new_domain_name_servers; do
				if [ -n "$NAMESERVERS" ]; then
					NAMESERVERS=$NAMESERVERS,\"$nameserver\"
				else
					NAMESERVERS=\"$nameserver\"
				fi
			done
			dhclientverbose_echo "NAMESERVERS $NAMESERVERS"
			if [ -n "$NAMESERVERS" ]; then
				NAMESERVERS=,\"nameservers\":[$NAMESERVERS]
			else
				NAMESERVERS=""
			fi
			dhclientverbose_echo "NAMESERVERS $NAMESERVERS"
			
			DM=""
			if [ "x$new_domain_search" != x ]; then
				DM=,\"searchdomains\":\"$new_domain_search\"
			elif [ "x$new_domain_name" != x ]; then
			    DM=,\"searchdomains\":\"$new_domain_name\"
			fi
			
			dhclientverbose_echo "GW $GW"
			dhclientverbose_echo "DM $DM"
			dhclientverbose_echo "NAMESERVERS $NAMESERVERS"
			
			cat - > $PPSOBJ <<EOF
msg::net_dyn
id::1
dat::["$interface",0,{$GW$NAMESERVERS$DM}]
EOF
		fi
	elif [ "x${new_dhcp6_name_servers}" != x ] ; then
		# IPv6
		if [ -e $PPSOBJ ]; then
			
			NAMESERVERS=
			for nameserver in $new_dhcp6_name_servers; do
				if [ -n "$NAMESERVERS" ]; then
					NAMESERVERS=$NAMESERVERS,\"$nameserver\"
				else
					NAMESERVERS=\"$nameserver\"
				fi
			done
			dhclientverbose_echo "NAMESERVERS $NAMESERVERS"
			if [ -n "$NAMESERVERS" ]; then
				NAMESERVERS=\"nameservers\":[$NAMESERVERS]
			else
				NAMESERVERS=""
			fi
			dhclientverbose_echo "NAMESERVERS $NAMESERVERS"
			
# Domain Search for IPv6 not supported
			DM=""
#			if [ "x$new_dhcp6_domain_search" != x ]; then
#				DM=,\"searchdomains\":\"$new_domain_search\"
#			fi		
#    if [ "x$new_domain_name" != x ]; then
#      DM=,\"searchdomains\":\"$new_domain_name\"
#    fi
			
#			dhclientverbose_echo "DM $DM"
			dhclientverbose_echo "NAMESERVERS $NAMESERVERS"
			
			cat - > $PPSOBJ <<EOF
msg::net_dyn
id::1
dat::["$interface",0,{$NAMESERVERS$DM}]
EOF
		fi
	fi
}

make_resolv_conf() {
  if [ $MODIFY_RESOLV = 0 ]; then
# This also does routers but it doesn't matter...
      make_pps_conf
			return
  fi
  if [ x"$new_domain_name_servers" != x ]; then
    if [ $RESOLV_TO_MEMORY = 0 ]; then
	    cat /dev/null > $WORKDIR/resolv.conf.dhclient
	    if [ "x$new_domain_search" != x ]; then
        echo search $new_domain_search >> $WORKDIR/resolv.conf.dhclient
      elif [ "x$new_domain_name" != x ]; then
        # Note that the DHCP 'Domain Name Option' is really just a domain
        # name, and that this practice of using the domain name option as
        # a search path is both nonstandard and deprecated.
        echo search $new_domain_name >> $WORKDIR/resolv.conf.dhclient
      fi
      for nameserver in $new_domain_name_servers; do
        echo nameserver $nameserver >> $WORKDIR/resolv.conf.dhclient
      done
      
      mv $WORKDIR/resolv.conf.dhclient /etc/resolv.conf

    else 
      cat /dev/null > $WORKDIR/resolv.conf.dhclient
#	    if [ "x$new_domain_search" != x ]; then elif
      if [ "x$new_domain_name" != x ]; then
        setconf _CS_DOMAIN $new_domain_name
      fi
      for nameserver in $new_domain_name_servers; do
        echo nameserver_$nameserver >> $WORKDIR/resolv.conf.dhclient
      done
#      orig_conf=getconf _CS_RESOLVE
      setconf _CS_RESOLVE ""
#      echo $orig_conf >> $WORKDIR/resolv.conf.dhclient
      new_conf=`cat $WORKDIR/resolv.conf.dhclient`
      setconf _CS_RESOLVE "$new_conf"
      rm $WORKDIR/resolv.conf.dhclient

    fi
  elif [ "x${new_dhcp6_name_servers}" != x ] ; then
    if [ $RESOLV_TO_MEMORY = 0 ]; then
      cat /dev/null > $WORKDIR/resolv.conf.dhclient6
      chmod 644 $WORKDIR/resolv.conf.dhclient6
      
      if [ "x${new_dhcp6_domain_search}" != x ] ; then
        echo search ${new_dhcp6_domain_search} >> $WORKDIR/resolv.conf.dhclient6
      fi
      for nameserver in ${new_dhcp6_name_servers} ; do
        echo nameserver ${nameserver} >> $WORKDIR/resolv.conf.dhclient6
      done

      mv $WORKDIR/resolv.conf.dhclient6 /etc/resolv.conf

    else
# IPv6 support in confstr?   
      cat /dev/null > $WORKDIR/resolv.conf.dhclient6
      
#      if [ "x${new_dhcp6_domain_search}" != x ] ; then
#        echo search ${new_dhcp6_domain_search} >> $WORKDIR/resolv.conf.dhclient6
#      fi
      for nameserver in ${new_dhcp6_name_servers} ; do
        echo nameserver_${nameserver} >> $WORKDIR/resolv.conf.dhclient6
      done
#      orig_conf=getconf _CS_RESOLVE
      setconf _CS_RESOLVE ""
#      echo $orig_conf >> $WORKDIR/resolv.conf.dhclient6
      new_conf=`cat $WORKDIR/resolv.conf.dhclient6`
      setconf _CS_RESOLVE "$new_conf"
      
      rm $WORKDIR/resolv.conf.dhclient6
      
    fi
  fi

}

# Must be used on exit.   Invokes the local dhcp client exit hooks, if any.
exit_with_hooks() {
  exit_status=$1
  if [ -f /etc/dhclient-exit-hooks ]; then
    . /etc/dhclient-exit-hooks
  fi
# probably should do something with exit status of the local script
  exit $exit_status
}

# Invoke the local dhcp client enter hooks, if they exist.
if [ -f /etc/dhclient-enter-hooks ]; then
  exit_status=0
  . /etc/dhclient-enter-hooks
  # allow the local script to abort processing of this state
  # local script must set exit_status variable to nonzero.
  if [ $exit_status -ne 0 ]; then
    exit $exit_status
  fi
fi

if [ x$new_network_number != x ]; then
   dhclientverbose_echo "New Network Number: $new_network_number"
fi

if [ x$new_broadcast_address != x ]; then
 dhclientverbose_echo "New Broadcast Address: $new_broadcast_address"
  new_broadcast_arg="broadcast $new_broadcast_address"
fi
if [ x$old_broadcast_address != x ]; then
  old_broadcast_arg="broadcast $old_broadcast_address"
fi
if [ x$new_subnet_mask != x ]; then
  new_netmask_arg="netmask $new_subnet_mask"
fi
if [ x$old_subnet_mask != x ]; then
  old_netmask_arg="netmask $old_subnet_mask"
fi
if [ x$alias_subnet_mask != x ]; then
  alias_subnet_arg="netmask $alias_subnet_mask"
fi
 if [ x$new_interface_mtu != x ]; then
   mtu_arg="mtu $new_interface_mtu"
 fi
if [ x$IF_METRIC != x ]; then
  metric_arg="metric $IF_METRIC"
fi

if [ x$reason = xMEDIUM ]; then
  ifconfig $interface $medium
  ifconfig $interface inet -alias 0.0.0.0 $medium >/dev/null 2>&1
  sleep 1
  exit_with_hooks 0
fi

###
### DHCPv4 Handlers
###

if [ x$reason = xRENEWING ]; then
    exit_with_hooks 0
fi

if [ x$reason = xPREINIT ]; then
  if [ x$alias_ip_address != x ]; then
    ifconfig $interface inet -alias $alias_ip_address > /dev/null 2>&1
    route delete $alias_ip_address 127.0.0.1 > /dev/null 2>&1
  fi
  ifconfig $interface inet 0.0.0.0 netmask 0.0.0.0 \
		broadcast 255.255.255.255 up
  exit_with_hooks 0
fi

if [ x$reason = xARPCHECK ] || [ x$reason = xARPSEND ]; then
  exit_with_hooks 0
fi
  
if [ x$reason = xBOUND ] || [ x$reason = xRENEW ] || \
   [ x$reason = xREBIND ] || [ x$reason = xREBOOT ]; then
  current_hostname=`hostname`
  if [ x$current_hostname = x ] || \
     [ x$current_hostname = x$old_host_name ]; then
    if [ x$current_hostname = x ] || \
       [ x$new_host_name != x$old_host_name ]; then
# NOT NECESSARY?      setconf _CS_HOSTNAME $new_host_name
      hostname $new_host_name
    fi
  fi
    
  if [ x$old_ip_address != x ] && [ x$alias_ip_address != x ] && \
		[ x$alias_ip_address != x$old_ip_address ]; then
    ifconfig $interface inet -alias $alias_ip_address > /dev/null 2>&1
    route delete $alias_ip_address 127.0.0.1 > /dev/null 2>&1
  fi
  if [ x$old_ip_address != x ] && [ x$old_ip_address != x$new_ip_address ]
   then
    ifconfig $interface inet -alias $old_ip_address $medium
    route delete $old_ip_address 127.1 >/dev/null 2>&1
    if [ $NO_DEF_ROUTE = 0 ]; then
			for router in $old_routers; do
				route delete default $router >/dev/null 2>&1
			done
    fi
    if [ "$old_static_routes" != "" ]; then
      set $old_static_routes
      while [ $# -gt 1 ]; do
	route delete $1 $2
	shift; shift
      done
    fi
    arp -n -a | sed -n -e 's/^.*(\(.*\)) at .*$/arp -n -d \1/p' |sh
  fi
  if [ x$old_ip_address = x ] || [ x$old_ip_address != x$new_ip_address ] || \
     [ x$reason = xBOUND ] || [ x$reason = xREBOOT ]; then
    ifconfig $interface inet $new_ip_address $new_netmask_arg \
			$mtu_arg $metric_arg $medium
    route add $new_ip_address 127.1 >/dev/null 2>&1
    if [ $NO_DEF_ROUTE = 0 ]; then
			for router in $new_routers; do
				route add default $router > /dev/null 2>&1
#      route add default $router >/dev/null 2>&1
			done
    fi
    if [ "$new_static_routes" != "" ]; then
      set $new_static_routes
      while [ $# -gt 1 ]; do
	route add $1 $2
	shift; shift
      done
    fi
  fi
  if [ x$new_ip_address != x$alias_ip_address ] && [ x$alias_ip_address != x ];
   then
    ifconfig $interface inet alias $alias_ip_address $alias_subnet_arg
    route add $alias_ip_address 127.0.0.1
  fi
  make_resolv_conf
  exit_with_hooks 0
fi

if [ x$reason = xEXPIRE ] || [ x$reason = xFAIL ] || [ x$reason = xRELEASE ] \
   || [ x$reason = xSTOP ]; then
# if FAIL consider error to PPS?

  ifconfig $interface inet -alias 0.0.0.0 $medium >/dev/null 2>&1

  if [ x$alias_ip_address != x ]; then
    ifconfig $interface inet -alias $alias_ip_address > /dev/null 2>&1
    route delete $alias_ip_address 127.0.0.1 > /dev/null 2>&1
  fi
  if [ x$old_ip_address != x ]; then
    ifconfig $interface inet -alias $old_ip_address $medium
    route delete $old_ip_address 127.1 >/dev/null 2>&1
    if [ $NO_DEF_ROUTE = 0 ]; then
			for router in $old_routers; do
				route delete default $router >/dev/null 2>&1
			done
    fi
    if [ "$old_static_routes" != "" ]; then
      set $old_static_routes
      while [ $# -gt 1 ]; do
	route delete $1 $2
	shift; shift
      done
    fi
    arp -n -a | sed -n -e 's/^.*(\(.*\)) at .*$/arp -n -d \1/p' \
						|sh >/dev/null 2>&1
  fi
  if [ x$alias_ip_address != x ]; then
    ifconfig $interface inet alias $alias_ip_address $alias_subnet_arg
    route add $alias_ip_address 127.0.0.1
  fi
  exit_with_hooks 0
fi

if [ x$reason = xTIMEOUT ]; then
# consider error to PPS?
  if [ x$alias_ip_address != x ]; then
    ifconfig $interface inet -alias $alias_ip_address > /dev/null 2>&1
    route delete $alias_ip_address 127.0.0.1 > /dev/null 2>&1
  fi
  ifconfig $interface inet $new_ip_address $new_netmask_arg \
			$mtu_arg $metric_arg $medium
  sleep 1
  if [ "$new_routers" != "" ]; then
    set $new_routers
    if ping -q -c 1 -w 1 $1; then
      if [ x$new_ip_address != x$alias_ip_address ] && \
			[ x$alias_ip_address != x ]; then
	ifconfig $interface inet alias $alias_ip_address $alias_subnet_arg
	route add $alias_ip_address 127.0.0.1
      fi
      route add $new_ip_address 127.1 >/dev/null 2>&1
      if [ $NO_DEF_ROUTE = 0 ]; then
				for router in $new_routers; do
					route add default $router >/dev/null 2>&1
				done
      fi
      set $new_static_routes
      while [ $# -gt 1 ]; do
	route add $0 $1
	shift; shift
      done
      make_resolv_conf
      exit_with_hooks 0
    fi
  fi
  ifconfig $interface inet -alias $new_ip_address $medium
  if [ $NO_DEF_ROUTE = 0 ]; then
    for router in $old_routers; do
			route delete default $router >/dev/null 2>&1
    done
  fi
  if [ "$old_static_routes" != "" ]; then
    set $old_static_routes
    while [ $# -gt 1 ]; do
      route delete $1 $2
      shift; shift
    done
  fi
  arp -n -a | sed -n -e 's/^.*(\(.*\)) at .*$/arp -n -d \1/p' \
							|sh >/dev/null 2>&1
  exit_with_hooks 1
fi

###
### DHCPv6 Handlers
###

if [ x$reason = xRENEWING6 ] ; then
    exit_with_hooks 0
fi

if [ x$reason = xPREINIT6 ] ; then
  # Ensure interface is up.
  ifconfig ${interface} up

  # XXX: Remove any stale addresses from aborted clients.

  exit_with_hooks 0
fi

if [ x${old_ip6_prefix} != x ] || [ x${new_ip6_prefix} != x ] ; then
    dhclientverbose_echo "Prefix $reason old=${old_ip6_prefix} new=${new_ip6_prefix}"

    exit_with_hooks 0
fi

if [ x$reason = xBOUND6 ] ; then
  if [ x${new_ip6_address} = x ] || [ x${new_ip6_prefixlen} = x ] ; then
    exit_with_hooks 2;
  fi

  ifconfig ${interface} inet6 ${new_ip6_address}/${new_ip6_prefixlen}
#  ifconfig ${interface} inet6 add ${new_ip6_address}/${new_ip6_prefixlen}

  # Check for nameserver options.
  make_resolv_conf

  exit_with_hooks 0
fi

if [ x$reason = xRENEW6 ] || [ x$reason = xREBIND6 ] ; then
  # Make sure nothing has moved around on us.

  # Nameservers/domains/etc.
  if [ "x${new_dhcp6_name_servers}" != "x${old_dhcp6_name_servers}" ] ||
     [ "x${new_dhcp6_domain_search}" != "x${old_dhcp6_domain_search}" ] ; then
    make_resolv_conf
  fi

  exit_with_hooks 0
fi

if [ x$reason = xDEPREF6 ] ; then
  if [ x${new_ip6_prefixlen} = x ] ; then
    exit_with_hooks 2;
  fi

  # XXX:
  # There doesn't appear to be a way to update an addr to indicate
  # preference.

  exit_with_hooks 0
fi

if [ x$reason = xEXPIRE6 -o x$reason = xRELEASE6 -o x$reason = xSTOP6 ] ; then
  if [ x${old_ip6_address} = x ] || [ x${old_ip6_prefixlen} = x ] ; then
    exit_with_hooks 2;
  fi

  ifconfig ${interface} inet6 -alias ${old_ip6_address}

  exit_with_hooks 0
fi

exit_with_hooks 0
