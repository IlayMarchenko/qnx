# This is a generated file, composed of the following suppression rules:
#  exp-sgcheck.supp xfree-3.supp xfree-4.supp nto.supp
{
   ld-2.X possibly applying relocations
   exp-sgcheck:SorG
   obj:*/*lib*/ld-2.*so*
   obj:*/*lib*/ld-2.*so*
}

# I'm pretty sure this is a false positive caused by the sg_ stuff
{
   glibc realpath false positive
   exp-sgcheck:SorG
   fun:realpath
   fun:*
}

{
   I think this is glibc's ultra optimised getenv doing 2 byte reads
   exp-sgcheck:SorG
   fun:getenv
}

##----------------------------------------------------------------------##

# Errors to suppress by default with XFree86 3.3.6)

# Format of this file is:
# {
#     name_of_suppression
#     tool_name:supp_kind
#     (optional extra info for some suppression types)
#     caller0 name, or /name/of/so/file.so
#     caller1 name, or ditto
#     (optionally: caller2 name)
#     (optionally: caller3 name)
#  }
#
# For Memcheck, the supp_kinds are:
#
#     Param Value1 Value2 Value4 Value8 Value16 Jump
#     Free Addr1 Addr2 Addr4 Addr8 Addr16
#     Cond (previously known as Value0)
#
# and the optional extra info is:
#     if Param: name of system call param

##----------------------------------------------------------------------##

{
   X11-Cond-0
   Memcheck:Cond
   obj:*libXt.so.6.0
   obj:*libXt.so.6.0
   obj:*libXt.so.6.0
}
{
   X11-Cond-1
   Memcheck:Cond
   fun:__rawmemchr
   obj:*libXt.so.6.0
   obj:*libXt.so.6.0
}


# Suppressions for XFree86-3.3.X

{
   X11-Addr4-1
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libX11.so.6.1
   obj:/usr/X11R6/lib/libX11.so.6.1
   obj:/usr/X11R6/lib/libX11.so.6.1
}

{
   X11-Addr4-2
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libX11.so.6.1
   obj:/usr/X11R6/lib/libX11.so.6.1
   obj:/usr/X11R6/lib/libXt.so.6.0
}

{
   X11-Addr4-3
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXt.so.6.0
}

{
   X11-Addr4-4
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libX11.so.6.1
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXt.so.6.0
}

{
   X11-Addr4-5
   Memcheck:Addr4
   fun:__rawmemchr
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXt.so.6.0
}

{
   X11-Addr4-6
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libXmu.so.6.0
   obj:/usr/X11R6/lib/libXmu.so.6.0
   obj:/usr/X11R6/lib/libXt.so.6.0
}

{
   X11-Addr4-7
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXawXpm_posing_as_Xaw.so.6.1
}

{
   X11-Param-1
   Memcheck:Param
   write(buf)
   fun:__libc_write
   obj:/usr/X11R6/lib/libX11.so.6.1
   obj:/usr/X11R6/lib/libX11.so.6.1
}

{
   X11-Addr4-8
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libX11.so.6.1
   obj:/usr/X11R6/lib/libXpm.so.4.11
   obj:/usr/X11R6/lib/libXpm.so.4.11
}

{
   X11-Addr4-8
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXawXpm_posing_as_Xaw.so.6.1
   obj:/usr/X11R6/lib/libXt.so.6.0
}

{
   X11-Addr4-9
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libXaw.so.6.1
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXt.so.6.0
}

{
   X11-Addr4-10
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libXaw.so.6.1
   obj:/usr/X11R6/lib/libXaw.so.6.1
   obj:/usr/X11R6/lib/libXt.so.6.0
}

{
   X11-Addr4-11
   Memcheck:Addr4
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXt.so.6.0
   obj:/usr/X11R6/lib/libXaw.so.6.1
}



##----------------------------------------------------------------------##

##----------------------------------------------------------------------##

# Errors to suppress by default with XFree86 4.1.0)

# *** And a bunch of other stuff which is completely unrelated
# to X.  The default suppressions are a bit of a mess and could do
# with a good tidying up.

# Format of this file is:
# {
#     name_of_suppression
#     tool_name:supp_kind
#     (optional extra info for some suppression types)
#     caller0 name, or /name/of/so/file.so
#     caller1 name, or ditto
#     (optionally: caller2 name)
#     (optionally: caller3 name)
#  }
#
# For Memcheck, the supp_kinds are:
#
#     Param Value1 Value2 Value4 Value8 Value16 Jump
#     Free Addr1 Addr2 Addr4 Addr8 Addr16
#     Cond (previously known as Value0)
#
# and the optional extra info is:
#     if Param: name of system call param

# Resulting from R H 8.0
{
   *libc_write/libX11.so.6.2/*X11TransWrite(Param)
   Memcheck:Param
   write(buf)
   fun:*libc_write
   obj:/usr/*lib*/libX11.so*
   fun:*X11TransWrite
}

{
   libX11.so.6.2/libX11.so.6.2/libX11.so.6.2(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libX11.so*
   obj:/usr/*lib*/libX11.so*
   obj:/usr/*lib*/libX11.so*
}

{
   libXt.so.6.2/libXt.so.6.2/libXt.so.6.2(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libXt.so*
   obj:/usr/*lib*/libXt.so*
   obj:/usr/*lib*/libXt.so*
}


{
   libXaw.so.7.0/libXaw.so.7.0/libXaw.so.7.0(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libXaw.so*
   obj:/usr/*lib*/libXaw.so*
   obj:/usr/*lib*/libXaw.so*
}

{
   libXmu.so.6.2/libXmu.so.6.2/libXmu.so.6.2(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libXmu.so*
   obj:/usr/*lib*/libXmu.so*
   obj:/usr/*lib*/libXmu.so*
}

{
   libXt.so.6.0/libXt.so.6.0/libXaw.so.7.0(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libXt.so*
   obj:/usr/*lib*/libXt.so*
   obj:/usr/*lib*/libXaw.so*
}

{
   libXaw.so.7.0/libXaw.so.7.0/libXt.so.6.0(Value4)
   Memcheck:Value4
   obj:/usr/*lib*/libXaw.so*
   obj:/usr/*lib*/libXaw.so*
   obj:/usr/*lib*/libXt.so*
}

{
   libXaw.so.7.0/libXaw.so.7.0/libXt.so.6.0(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libXaw.so*
   obj:/usr/*lib*/libXaw.so*
   obj:/usr/*lib*/libXt.so*
}

{
   libX11.so.6.2/libX11.so.6.2/libXaw.so.7.0(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libX11.so*
   obj:/usr/*lib*/libX11.so*
   obj:/usr/*lib*/libXaw.so*
}

{
   libX11.so.6.2/libX11.so.6.2/libXaw.so.7.0(Addr4)
   Memcheck:Addr4
   obj:/usr/*lib*/libX11.so*
   obj:/usr/*lib*/libX11.so*
   obj:/usr/*lib*/libXaw.so*
}

{
   libX11.so.6.2/libXaw.so.7.0/libXaw.so.7.0(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libX11.so*
   obj:/usr/*lib*/libXaw.so*
   obj:/usr/*lib*/libXaw.so*
}

{
   libXpm.so.4.11/libXpm.so.4.11/libXpm.so.4.11
   Memcheck:Cond
   obj:/usr/*lib*/libXpm.so.4.11
   obj:/usr/*lib*/libXpm.so.4.11
   obj:/usr/*lib*/libXpm.so.4.11
}

{
   struct with uninitialized paddings
   Memcheck:Param
   writev(vector[...])
   fun:*_writev
   fun:_X11TransSocketWritev
   fun:_X11TransWritev
   fun:*
}

{
   struct with uninitialized paddings - libxcb
   Memcheck:Param
   writev(vector[...])
   obj:/lib*/*.so
   obj:/usr/lib*/libxcb.so.1.0.0
   obj:/usr/lib*/libxcb.so.1.0.0
   fun:xcb_send_request
   fun:_X*
}

{
   struct with uninitialized paddings - libxcb
   Memcheck:Param
   writev(vector[...])
   obj:/lib*/*.so
   obj:/usr/lib*/libxcb.so.1.0.0
   obj:/usr/lib*/libxcb.so.1.0.0
   obj:/usr/lib*/libxcb.so.1.0.0
   fun:xcb_*
   fun:_X*
}

{
   another struct with uninitialized paddings
   Memcheck:Param
   write(buf)
   obj:*
   fun:_IceTransSocketWrite
   fun:_IceTransWrite
   fun:_IceWrite
}

{
   Xorg 6.8.1 uninit _write* padding
   Memcheck:Param
   write(buf)
   fun:*
   fun:_X11TransWrite
   obj:/usr/*lib*/libX11.so*
}

{
   Xorg 6.8.1 uninit write padding
   Memcheck:Param
   write(buf)
   fun:write
   fun:_X11TransWrite
   obj:/usr/*lib*/libX11.so*
}

{
   Xorg 6.8.1 ICE uninit __write* padding
   Memcheck:Param
   write(buf)
   obj:*
   fun:_IceTransWrite
   fun:_IceWrite
   fun:IceFlush
}

{
   Xorg 6.8.1 writev uninit padding
   Memcheck:Param
   writev(vector[...])
   fun:writev
   obj:/usr/*lib*/libX11.so*
   fun:_X11TransWritev
   fun:_XSend
}

{
   Xorg 6.9.0 writev uninit padding
   Memcheck:Param
   writev(vector[...])
   fun:do_writev
   fun:writev
   obj:/usr/*lib*/libX11.so*
   fun:_X11TransWritev
   fun:_XSend
}

{
   X on SUSE11 writev uninit padding
   Memcheck:Param
   writev(vector[...])
   fun:writev
   obj:/usr/lib*/libxcb.so*
   obj:/usr/lib*/libxcb.so*
}
{
   X on SUSE11 writev uninit padding 2
   Memcheck:Param
   writev(vector[...])
   obj:/lib*/ld-2.*.so*
   obj:/usr/lib*/libxcb.so*
   obj:/usr/lib*/libxcb.so*
}
{
   X on SUSE11 writev uninit padding 3
   Memcheck:Param
   writev(vector[...])
   obj:/lib*/ld-2.*.so*
   obj:/usr/lib*/libORBit*.so*
   obj:/usr/lib*/libORBit*.so*
}
{
   X on SUSE11 writev uninit padding 4
   Memcheck:Param
   writev(vector[...])
   obj:/lib*/libc-2.*.so*
   obj:/usr/lib*/libORBit*.so*
   obj:/usr/lib*/libORBit*.so*
}
 

# There's something strange about a % 127 in XftFontOpenInfo
# (hashing) which gcc turns into a multiply by 33818641 and
# some other guff instead.  I don't understand it enough to
# know if libXft is broken or if memcheck's value tracking is
# inadequate here.  Anyway, for the moment, suppress it.
#
# Use of uninitialised value of size 8
#   at 0x71A59F8: XftFontOpenInfo (in /usr/X11R6/lib64/libXft.so.2.1.2)
#   by 0x71A5F0D: XftFontOpenPattern (in /usr/X11R6/lib64/libXft.so.2.1.2)
#   by 0x65F166E: loadFontConfigFont(QFontPrivate const*, QFontDef const&, 
#                 QFont::Script) (qfontdatabase_x11.cpp:1942)
#   by 0x65F5DE4: QFontDatabase::findFont(QFont::Script, QFontPrivate const*,
#                 QFontDef const&, int) (qfontdatabase.cpp:996)
{
   XftFontOpenInfo-umod-127-strangeness
   Memcheck:Value8
   obj:/usr/X11*/lib*/libXft.so*
   obj:/usr/X11*/lib*/libXft.so*
}
{
   XftFontOpenInfo-umod-127-strangeness-a-la-xorg
   Memcheck:Value8
   obj:/usr/lib*/libXft.so*
   obj:/usr/lib*/libXft.so*
}

{
   More X padding stuff
   Memcheck:Param
   writev(vector[...])
   fun:*writev*
   obj:/usr/X11*/lib*/libX11.so*
   obj:/usr/X11*/lib*/libX11.so*
}

# Inlined strlen in libX11 on Ubuntu 9.10 amd64, unfortunately.
# Invalid read of size 4
#    at 0x9B5CCE6: ??? (in /usr/lib/libX11.so.6.2.0)
#    by 0x9B5D011: XGetAtomName (in /usr/lib/libX11.so.6.2.0)
#    by 0x86407C3: gdk_x11_xatom_to_atom_for_display
#                  (in /usr/lib/libgdk-x11-2.0.so.0.1800.3)
#    by 0x8636817: ??? (in /usr/lib/libgdk-x11-2.0.so.0.1800.3)
#  Address 0x1a558e1c is 28 bytes inside a block of size 30 alloc'd
#    at 0x4C2552D: malloc (vg_replace_malloc.c:236)
#    by 0x9B642C0: _XUpdateAtomCache (in /usr/lib/libX11.so.6.2.0)
#    by 0x9B647F1: ??? (in /usr/lib/libX11.so.6.2.0)
#    by 0x9B81818: ??? (in /usr/lib/libX11.so.6.2.0)
{
   libX11.so.6.2.0/libX11.so.6.2.0(Addr4)
   Memcheck:Addr4
   obj:/usr/*lib*/libX11.so*
   obj:/usr/*lib*/libX11.so*
}

##----------------------------------------------------------------------##
# Completely inappropriate place, but ...

{
   ifort-9.X-on-i686-1
   Memcheck:Addr4
   fun:unaligned_bigint
   fun:hash
   fun:for__add_to_lf_table
}
{
   ifort-9.X-on-amd64-1
   Memcheck:Addr8
   fun:unaligned_bigint
   fun:hash
   fun:for__add_to_lf_table
}


# zlib-1.2.x uses uninitialised memory in some tricky way which
# apparently is harmless (it must amount to a vectorised while-loop,
# nothing else makes sense).  Fools Memcheck though.  See the mentioned
# URL for details.
{
   zlib-1.2.x trickyness (1a): See http://www.zlib.net/zlib_faq.html#faq36
   Memcheck:Cond
   obj:/*lib*/libz.so.1.2.*
   ...
   obj:/*lib*/libz.so.1.2.*
   fun:deflate
}
{
   zlib-1.2.x trickyness (1b): See http://www.zlib.net/zlib_faq.html#faq36
   Memcheck:Cond
   obj:/*lib*/libz.so.1.2.*
   fun:deflate
}

{
   zlib-1.2.x trickyness (2a): See http://www.zlib.net/zlib_faq.html#faq36
   Memcheck:Value8
   obj:/*lib*/libz.so.1.2.*
   ...
   obj:/*lib*/libz.so.1.2.*
   fun:deflate
}
{
   zlib-1.2.x trickyness (2b): See http://www.zlib.net/zlib_faq.html#faq36
   Memcheck:Value8
   obj:/*lib*/libz.so.1.2.*
   fun:deflate
}

{
   zlib-1.2.x trickyness (3a): See http://www.zlib.net/zlib_faq.html#faq36
   Memcheck:Value4
   obj:/*lib*/libz.so.1.2.*
   ...
   obj:/*lib*/libz.so.1.2.*
   fun:deflate
}
{
   zlib-1.2.x trickyness (3b): See http://www.zlib.net/zlib_faq.html#faq36
   Memcheck:Value4
   obj:/*lib*/libz.so.1.2.*
   fun:deflate
}


##----------------------------------------------------------------------##

## More general versions of some of the old X suppressions above
{
   Ubuntu804 libXaw.so.7.0/libXaw.so.7.0/libXaw.so.7.0(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libXaw*so*
   obj:/usr/*lib*/libXaw*so*
   obj:/usr/*lib*/libXaw*so*
}
{
   Ubuntu804 libXaw.so.7.0/libXaw.so.7.0/libXt(Cond)
   Memcheck:Cond
   obj:/usr/*lib*/libXaw*so*
   obj:/usr/*lib*/libXaw*so*
   obj:/usr/*lib*/libXt*so*
}

{
   Ubuntu804-hack-1
   Memcheck:Overlap
   fun:mempcpy
   fun:_IO_default_xsputn
   obj:/lib*/libc-2.*so*
}
{
   _vfcntl
   Memcheck:Param
   MsgSend(smsg)
   fun:MsgSendnc
   fun:_vfcntl
   ...
}

{
   _vfcntl_2
   Memcheck:Param
   MsgSendv(siov[0])
   fun:MsgSendv
   fun:_vfcntl
   ...
}

{  
   _vfcntl_3
   Memcheck:Param
   MsgSendv(siov[1])
   fun:MsgSendv
   fun:_vfcntl
   ...
}

{
   slogsend
   Memcheck:Param
   MsgSendv(siov[1])
   fun:MsgSendv
   fun:slogsend
   ...
}

{
   ionotify
   Memcheck:Param
   MsgSend(smsg)
   fun:MsgSend
   fun:ionotify
   ...
}

{
   trace_logbc
   Memcheck:Param
   TraceEvent(data)
   ...
   fun:TraceEvent
   fun:trace_logbc
   ...
}

{
   connect_extra_2
   Memcheck:Param
   MsgSendv(siov[2])
   fun:MsgSendvnc
   ...
   fun:_connect
   obj:*libc.so.*
   ...
}

{
   connect_extra_3
   Memcheck:Param
   MsgSendv(siov[3])
   fun:MsgSendvnc
   ...
   fun:_connect
   obj:*libc.so.*
   ...
}

{
   android_syscalls
   Memcheck:Addr4
   fun:handle_syscall
   ...
}

{
   gc_graphics_1
   Memcheck:Addr1
   ...
   obj:*/usr/lib/graphics/qc/*.so
   ...
}

{
   gc_graphics_2
   Memcheck:Addr2
   ...
   obj:*/usr/lib/graphics/qc/*.so
   ...
}

{
   gc_graphics_4
   Memcheck:Addr4
   ...
   obj:*/usr/lib/graphics/qc/*.so
   ...
}

{
   gc_graphics_8
   Memcheck:Addr8
   ...
   obj:*/usr/lib/graphics/qc/*.so
   ...
}

{
   gc_graphics_16
   Memcheck:Addr16
   ...
   obj:*/usr/lib/graphics/qc/*.so
   ...
}

{
   ldd_atfork
   Memcheck:Leak
   fun:malloc
   fun:pthread_atfork
   ...
}

{
   loader_malloc
   Memcheck:Leak
   fun:malloc
   ...
   fun:__ldd
   fun:ldd
   ...
}

# TODO: These are too broad, could they be made more specific?
{
   loader_calloc
   Memcheck:Leak
   fun:calloc
   ...
   fun:__ldd
   fun:ldd
   ...
}
{
   loader_malloc
   Memcheck:Leak
   fun:malloc
   ...
   fun:__ldd
   ...
}

# 650sp1 does not free elements in the atexit list
{
   atexit_malloc
   Memcheck:Leak
   fun:malloc
   fun:atexit
   ...
}
{
   atexit_calloc
   Memcheck:Leak
   fun:calloc
   fun:atexit
   ...
}
{
   atexit_cxa_malloc
   Memcheck:Leak
   fun:malloc
   fun:__cxa_atexit
   ...
}
{
   atexit_cxa_calloc
   Memcheck:Leak
   fun:calloc
   fun:__cxa_atexit
   ...
}

# The destructor table is allocated on the first call to
# pthread_create_key, but is never freed.
{
   pthread_key_create
   Memcheck:Leak
   fun:malloc
   fun:pthread_key_create
   ...
}



{
   setvbuf
   Memcheck:Leak
   fun:malloc
   fun:setvbuf
}

# We don't setup an atexit() handler to free up the file lock list
{
   init_locks
   Memcheck:Leak
   fun:malloc
   fun:_Initlocks
   obj:*libc.so.*
   ...
}

{
   getcloc
   Memcheck:Leak
   fun:malloc
   fun:initcloc
   fun:__pthread_once
   fun:_Getcloc
}

{
   getctyptab
   Memcheck:Leak
   fun:calloc
   fun:_Getctyptab
}

{
   global_ios_base
   Memcheck:Leak
   ...
   fun:_Znwj
   ...
   fun:_GLOBAL__sub_I_wiostrea.cpp
   ...
}

{
   files
   Memcheck:Leak
   fun:malloc
   fun:_Fbuf
   obj:*libc.so.*
   ...
}

{
   setenv
   Memcheck:Leak
   fun:malloc
   fun:setenv
   ...
}

{
   _findenv
   Memcheck:Leak
   fun:malloc
   fun:_findenv
   ...
}

# On the 650sp1 release it seems as though the atexit isn't initializing
# all the cxa members which will cause valgrind to complain on exit.
{
   __cxa_finalize
   Memcheck:Cond
   fun:__cxa_finalize
   ...
#  But we don't always get a full trace :/
#  fun:exit
#  ...
}


# When destorying sync objects that internally use mutexes they will ensure
# they are holding the lock before destroying it. This is expected, so no
# need to complain about them.
{
   barrier_destroy_with_mutex_locked
   Helgrind:Misc
   fun:mutex_destroy_WRK
   fun:pthread_mutex_destroy
   ...
   fun:pthread_barrier_destroy
   ...
}

{
   rwlock_destroy_with_mutex_locked
   Helgrind:Misc
   fun:mutex_destroy_WRK
   fun:pthread_mutex_destroy
   ...
   fun:pthread_rwlock_destroy
   ...
}

# The emulated tls has a race in it, but it will also lock to
# recheck, so its not really a problem and should be suppressed.
{
   hg_emutls_race
   Helgrind:Race
   fun:__emutls_get_address
   ...
}
{
   drd_emutls_race
   drd:ConflictingAccess
   ...
   fun:__emutls_get_address
   ...
}

{
   _Mtxlock
   drd:ConflictingAccess
   fun:_Mtxlock
   obj:*libc.so.*
   ...
}

{
   _Mtxlock_empty
   drd:ConflictingAccess
   fun:_Mtxlock
}

{
   _Mtxunlock
   drd:ConflictingAccess
   fun:_Mtxunlock
   obj:*libc.so.*
   ...
}

{
   _Mtxunlock_empty
   drd:ConflictingAccess
   fun:_Mtxunlock
}

{
   _Lockfilelock
   drd:ConflictingAccess
   ...
   fun:_Lockfilelock
   obj:*libc.so.*
   ...
}

# Relocations need to be quick, and will attempt to do so without locking.
# This will cause some false positives to be reported.
{
   resolve_func
   drd:ConflictingAccess
   ...
   fun:__resolve_func
   ...
}
{
   resolve_func_650
   drd:ConflictingAccess
   ...
   fun:resolve_func
   ...
}

# pthread_exit() does a bunch of cleanup with no regard
# for other threads, which may result in a lot of noise
# over conflicting stores.
{
    pthread_exit_filemtx_access
    drd:ConflictingAccess
    fun:_Unlockfilemtx
    fun:pthread_exit
    ...
}
{
    pthread_exit_filemtx_lock
    drd:MutexErr
    ...
    fun:_Locksyslock
    fun:_Unlockfilemtx
    fun:pthread_exit
    ...
}
{
    pthread_exit_sysmtx_access
    drd:ConflictingAccess
    fun:_Unlocksysmtx
    fun:pthread_exit
    ...
}
{
    pthread_exit_sysmtx_lock
    drd:MutexErr
    ...
    fun:_Locksyslock
    fun:_Unlocksysmtx
    fun:pthread_exit
    ...
}
{
    pthread_exit_keydata
    drd:ConflictingAccess
    fun:pthread_exit
    ...
}

# pthread_create will unconditionally set _Multi_threaded=1, so if many threads
# are created and set the same variable conflicting stores will be reported.
{
    pthread_exit_keydata
    drd:ConflictingAccess
    fun:pthread_create
    ...
}

{
   pthread_rwlock_destroy
   drd:MutexErr
   fun:pthread_mutex_destroy
   fun:pthread_rwlock_destroy
   ...
}

# ldd's cleanup is done without locking, and may result in drd reporting
# a conflict when setting the objects flags.
{
   exit
   drd:ConflictingAccess
   obj:*libc.so.*
   ...
   fun:_do_exit_fini
   obj:*libc.so.*
   ...
}

# It's not uncommon for mutexes to be re-initialized in the child after a fork.
# TODO: If mutexes are not inherited on fork, perhaps this logic should be in drd?
{
   fork_mutex_reinit
   drd:MutexErr
   ...
   fun:_fork
   ...
}
{
   pthread_once
   drd:MutexErr
   ...
   fun:pthread_mutex_lock
   fun:__pthread_once
   fun:pthread_once
   fun:pthread_once
   ...
}
{
   fork_child_1
   drd:MutexErr
   ...
   fun:pthread_mutex_init
   fun:__pthread_once_child
   fun:_fork
   ...
}
{
   fork_child_2
   drd:MutexErr
   ...
   fun:pthread_mutex_init
   fun:*ldd_fork_child
   fun:_fork
   ...
}
{
   fork_child_3
   drd:MutexErr
   fun:pthread_mutex_init
   fun:key_child
   fun:_fork
   ...
}
{
   fork_child_4
   drd:MutexErr
   ...
   fun:pthread_mutex_init
   fun:_fork
   ...
}

# Although there are no suppressions for massif, I thought these commonly
# ignored functions needed to be documented somewhere.
#
# --ignore-fn=pthread_key_create
# --ignore-fn=pthread_setspecific
# --ignore-fn=atexit
# --ignore-fn=pthread_atfork
# --ignore-fn=ConnectClientInfoAble
# --ignore-fn=__cxa_atexit
# --ignore-fn=_GLOBAL__sub_I_eh_alloc.cc


{
   loader_1
   exp-sgcheck:SorG
   ...
   fun:resolve_obj
   obj:*libc.so.*
}

{
   loader_2
   exp-sgcheck:SorG
   ...
   fun:__ldd
   obj:*libc.so.*
}

{
   loader_3
   exp-sgcheck:SorG
   ...
   fun:load_elf
   obj:*libc.so.*
}

{
   libc_tzset
   Memcheck:Leak
   fun:calloc
   fun:tzset
   ...
}

{
   ldd_connect_request_1a
   Memcheck:Cond
   fun:__cortex_a9_strlen
   fun:_connect_request
   fun:_connect_request
   ...
   fun:_connect_request
   fun:_connect_request
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_1b
   Memcheck:Cond
   fun:_connect_request
   fun:_connect_request
   ...
   fun:_connect_request
   fun:_connect_request
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_1c
   Memcheck:Cond
   fun:__krait_neon_memcpy
   fun:_connect_request
   fun:_connect_request
   ...
   fun:_connect_request
   fun:_connect_request
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_2a
   Memcheck:Cond
   fun:__cortex_a9_strlen
   fun:_connect_ctrl
   fun:_connect_entry
   fun:_connect
   fun:__access
   fun:searchpath.constprop.19
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_2b
   Memcheck:Cond
   fun:_connect_request
   fun:_connect_ctrl
   fun:_connect_entry
   fun:_connect
   fun:__access
   fun:searchpath.constprop.19
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_2c
   Memcheck:Param
   MsgSend(siov)
   fun:MsgSendvnc
   fun:_connect_request
   fun:_connect_ctrl
   fun:_connect_entry
   fun:_connect
   fun:__access
   fun:searchpath.constprop.19
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_2d
   Memcheck:Param
   MsgSendv(siov[0])
   fun:MsgSendvnc
   fun:_connect_request
   fun:_connect_ctrl
   fun:_connect_entry
   fun:_connect
   fun:__access
   fun:searchpath.constprop.19
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_3a
   Memcheck:Param
   MsgSend(siov)
   fun:MsgSendv
   fun:_connect_request
   fun:_connect_ctrl
   fun:_connect_entry
   fun:_connect
   fun:_vopen
   fun:sopen
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_3b
   Memcheck:Param
   MsgSend(siov[0])
   fun:MsgSendv
   fun:_connect_request
   fun:_connect_ctrl
   fun:_connect_entry
   fun:_connect
   fun:_vopen
   fun:sopen
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_3c
   Memcheck:Param
   MsgSendv(siov[0])
   fun:MsgSendv
   fun:_connect_request
   fun:_connect_ctrl
   fun:_connect_entry
   fun:_connect
   fun:_vopen
   fun:sopen
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_4a
   Memcheck:Param
   MsgSendv(siov[0])
   fun:MsgSendvnc
   fun:_connect_request
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_4b
   Memcheck:Param
   MsgSend(siov)
   fun:MsgSendvnc
   fun:_connect_request
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_5a
   Memcheck:Cond
   fun:__cortex_a9_strlen
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_5b
   Memcheck:Cond
   fun:__cortex_a9_strlen
   fun:_connect_request
   ...
   fun:_connect_request
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_5c
   Memcheck:Cond
   fun:_connect_request
   ...
   fun:_connect_request
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

{
   ldd_connect_request_5d
   Memcheck:Cond
   fun:__krait_neon_memcpy
   fun:_connect_request
   ...
   fun:_connect_request
   fun:_connect_ctrl
   fun:_fullpath
   fun:find_file
   fun:load_object
   fun:__ldd
   fun:ldd
   fun:_start_
}

